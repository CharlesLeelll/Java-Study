Java内存模型(Java Memory Model) JMM {
	
	 ___________________________					 _______________
	|线程 A	 <-->  工作内存		|					|	 主内存		|
	|			  共享变量副本	| <---JMM控制---> 	|				|
	|___________________________|					|	共享变量	|
													|	共享变量	|
	 ___________________________					|	共享变量	|
	|线程 B	 <-->  工作内存		|					|	共享变量	|
	|			  共享变量副本	| <---JMM控制---> 	|	共享变量	|
	|___________________________|					|	共享变量	|
													|	共享变量	|
	 ___________________________					|	共享变量	|
	|线程 C	 <-->  工作内存		|					|	共享变量	|
	|			  共享变量副本	| <---JMM控制---> 	|	共享变量	|
	|___________________________|					|_______________|
	
	
	JMM -- 一组规则
	
	主内存 {
		主要存储 Java实例对象(成员变量/局部变量)
		包括 共享的类信息, 常量, 静态变量
		由于共享, 可能会发现线程安全问题
	}
	
	工作内存 {
		主要存储 当前方法的所有本地变量信息(工作内存中存储着主内存的变量副本拷贝)
		线程中的本地变量对于其他线程不可见(私有)
		线程安全
	}
	
	
	指令重排 {
		编译器优化重排(不改变单线程程序语义,安排语句的执行顺序)
		指令并行重排(改变语句对应的机器指令的执行顺序)
		内存系统重排(缓存与内存的同步存在时间差)
	}
	
	JMM {
		原子性(一个操作是不可被中断的)
		可见性(线程修改变量后,其他线程能否立即得知变量值)
		有序性(单线程 -- 代码有序 多线程 -- 可能乱序)
	}
	
	JMM 中 happens-before 原则 {
		程序顺序原则 -- 线程内必须保证语义串行性(按照代码顺序执行)
		锁规则 -- 一个unlock操作先行发生于后面对同一个锁的lock操作
		volatile规则 -- 对一个volatile修饰的变量，对他的写操作先行发生于读操作
		线程启动规则 -- 线程的start()方法先于它的每一个动作
		传递性 -- A先于B,B先于C.A先于C
		线程终止规则 -- 线程的所有操作都先行发生于对此线程的终止检测
		线程中断规则 -- 对线程interrupt()方法的调用先行发生于被中断线程的代码所检测到的中断事件
		对象终止规则 -- 对象的构造函数执行，结束先于finalize()方法
	}
	
	volatile {
		保证被volatile修饰的变量对所有线程可见
		禁止指令重排序优化
	}
	
	final {
		修饰类 -- 类不能被继承 类中所有成员方法->final方法(隐式)
		修饰方法 -- 锁定方法,防止修改.(private方法->final方法(隐式))
		修饰变量 -- 初始化后能不能更改
	}
}