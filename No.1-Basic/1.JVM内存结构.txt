JVM内存结构分析 {

	内存由JVM自动管理
	(运行时数据区)
	JVM (Java Virtual Machine)内存分为 {
		方法区(Method Area)
		虚拟机栈(VM Stack)
		本地方法栈(Native Method Stack)
		堆(Heap)
		程序计数器(Program Counter Register)
	}
		
		程序计数器(Program Counter Register) {
			JVM中较小的一块内存区域
			保存当前线程执行的虚拟机字节码指令的内存地址
			多线程实现 {
				线程间轮流 切换/分配 处理器执行时间
			}
			每个线程设立一个程序计数器,各线程互不影响
			PCR -- 线程私有
		}
		
		虚拟机栈(VM Stack) {
			创建线程 --> 创建Java栈
			Java栈 -- 线程私有
			栈 -- n* 栈帧
			调用方法 *1 --> 压入栈帧 *1
			栈帧 -- 存储 方法数据/部分过程结果 的数据结构
			(方法 -- 调用->返回结果) == (栈帧 -- 入栈->出栈)
			栈 -- 后入先出 --> 只有一个活动的栈帧(当前活动栈帧(栈顶))
		}
		
		
		本地方法栈(Native Method Stack) {
			类似虚拟机栈(Java方法)
			本地方法栈(Native方法)
		}
		
		方法区(Method Area) {
			存储 -- 类结构信息(常量池, 静态变量, 构造函数...)
			垃圾收集 -- JVM会回收一个未被引用类所占的空间 -- 方法区空间↓->最小
			常量池 -- 常量, 符号引用(加载类的连接阶段中的解析过程会将符号引用转换为直接引用)
			线程共享
		}
		
		堆(Heap) {
			存储 -- Java实例/对象
			GC(Garbage Collection)主要区域
		}

		
	直接内存 与 堆内存 比较 {
		直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显
		直接内存IO读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显
	}
}
	
总结 {
	
	所有线程共享的内存区域 -- 方法区, 堆
	线程私有区域 -- 虚拟机栈, 本地方法栈, 程序计数器
	
	栈 {
		每个线程 -- 一个栈区 保存基础数据类型的对象 和 自定义对象的引用
		栈中的数据 -- 私有 其他栈不能访问
		存放 {
			方法的形式参数 -- 方法调用完毕后回收
			引用对象的地址 -- 引用完毕后 -- 栈空间地址立即回收,堆空间等待GC
		}
	}
	
	堆 {
		存储对象(每个对象包含一个对应的class信息)
		只有一个堆区,所有线程共享,只存放对象本身
	}
	
	方法区 {
		存放线程所执行的字节码指令
		所有线程共享
		包含所有的class 和 static变量
		常量池在方法区中
	}
}
		